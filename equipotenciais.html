<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simula√ß√£o - Cuba Eletrol√≠tica</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            padding: 20px;
            gap: 20px;
        }
        
        .container {
            display: grid;
            grid-template-columns: 800px 1fr;
            grid-template-rows: auto auto;
            gap: 20px;
            width: 100%;
            max-width: 1600px;
            margin: 0 auto;
        }
        
        .simulation-container {
            grid-column: 1;
            grid-row: 1;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            padding: 20px;
            display: flex;
            flex-direction: column;
        }
        
        .flowchart-container {
            grid-column: 2;
            grid-row: 1;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            padding: 25px;
            display: flex;
            flex-direction: column;
            max-height: 600px;
        }
        
        .flowchart-scroll {
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 10px;
            flex: 1;
        }
        
        .flowchart-scroll::-webkit-scrollbar {
            width: 8px;
        }
        
        .flowchart-scroll::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        
        .flowchart-scroll::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 10px;
        }
        
        .flowchart-scroll::-webkit-scrollbar-thumb:hover {
            background: #5568d3;
        }
        
        .controls-container {
            grid-column: 1 / 3;
            grid-row: 2;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            padding: 25px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .flowchart-box {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            position: relative;
        }
        
        .flowchart-box.input {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        
        .flowchart-box.process {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }
        
        .flowchart-box.output {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
        }
        
        .flowchart-arrow {
            text-align: center;
            font-size: 24px;
            color: #667eea;
            margin: 5px 0;
        }
        
        .flowchart-note {
            background: #f0f4ff;
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            color: #555;
            border-left: 4px solid #667eea;
            margin-top: 5px;
        }
        
        h1 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 24px;
        }
        
        h2 {
            color: #667eea;
            font-size: 18px;
            margin-bottom: 15px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 8px;
        }
        
        .info-box {
            background: #f0f4ff;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            font-size: 13px;
            line-height: 1.6;
            color: #555;
        }
        
        .charge-control {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 12px;
            border: 2px solid #e0e0e0;
            transition: all 0.3s;
        }
        
        .charge-control:hover {
            border-color: #667eea;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
        }
        
        .charge-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .charge-label {
            font-weight: bold;
            color: #333;
            font-size: 14px;
        }
        
        .charge-value {
            font-family: 'Courier New', monospace;
            color: #667eea;
            font-weight: bold;
            font-size: 14px;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            background: #5568d3;
            transform: scale(1.2);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
        }
        
        button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 13px;
        }
        
        .btn-primary {
            background: #667eea;
            color: white;
        }
        
        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: #e0e0e0;
            color: #555;
        }
        
        .btn-secondary:hover {
            background: #d0d0d0;
        }
        
        .legend {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            font-size: 13px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            gap: 10px;
        }
        
        .legend-color {
            width: 30px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        
        #simulationCanvas {
            border-radius: 10px;
            box-shadow: inset 0 2px 8px rgba(0,0,0,0.1);
        }
        
        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto;
            }
            
            .simulation-container {
                grid-column: 1;
                grid-row: 1;
            }
            
            .flowchart-container {
                grid-column: 1;
                grid-row: 2;
            }
            
            .controls-container {
                grid-column: 1;
                grid-row: 3;
            }
        }
    </style>
</head>
<body>
    
    <div class="container">
        <!-- SIMULA√á√ÉO √Ä ESQUERDA (TOPO) -->
        <div class="simulation-container">
            <!-- Bot√µes de Navega√ß√£o -->
            <div id="navigation-buttons">
                <a href="campo_eletrico.html" class="nav-button">
                    <span class="nav-icon">‚ö°</span>
                    <span class="nav-text">Campo El√©trico</span>
                </a>
                <a href="campo_magnetico.html" class="nav-button">
                    <span class="nav-icon">üß≤</span>
                    <span class="nav-text">Campo Magn√©tico</span>
                </a>
            </div>
            <h1>‚ö° Simula√ß√£o de Cuba Eletrol√≠tica</h1>
            <div class="info-box">
                <strong>Como usar:</strong> Arraste as cargas com o mouse para mov√™-las. Use os controles abaixo para ajustar os valores das cargas. As linhas equipotenciais se atualizam automaticamente.
            </div>
            <div id="canvasContainer"></div>
        </div>
        
        
        <!-- FLUXOGRAMA √Ä DIREITA -->
        <div class="flowchart-container">
            <h2 style="margin-bottom: 15px;">üî¨ Experimento: Cuba Eletrol√≠tica</h2>
            
            <div class="flowchart-scroll">
                <div class="flowchart-box input">
                    üß™ MONTAGEM<br>
                    Cuba com solu√ß√£o condutora
                </div>
                <div class="flowchart-note">
                    Recipiente raso contendo √°gua + sal ou sulfato de cobre (eletr√≥lito) que conduz corrente el√©trica
                </div>
                
                <div class="flowchart-arrow">‚Üì</div>
                
                <div class="flowchart-box input">
                    ‚ö° ELETRODOS<br>
                    Inser√ß√£o das cargas
                </div>
                <div class="flowchart-note">
                    Eletrodos met√°licos (positivo e negativo) s√£o colocados na solu√ß√£o em diferentes posi√ß√µes
                </div>
                
                <div class="flowchart-arrow">‚Üì</div>
                
                <div class="flowchart-box process">
                    üîã APLICA√á√ÉO DE TENS√ÉO<br>
                    Diferen√ßa de potencial (ddp)
                </div>
                <div class="flowchart-note">
                    Fonte de tens√£o conectada aos eletrodos cria campo el√©trico na solu√ß√£o
                </div>
                
                <div class="flowchart-arrow">‚Üì</div>
                
                <div class="flowchart-box process">
                    ‚ö° CAMPO EL√âTRICO<br>
                    Distribui√ß√£o espacial
                </div>
                <div class="flowchart-note">
                    O campo el√©trico se espalha pela cuba de acordo com V = k¬∑Œ£(q/r)
                </div>
                
                <div class="flowchart-arrow">‚Üì</div>
                
                <div class="flowchart-box process">
                    üìç SONDA DE MEDI√á√ÉO<br>
                    Mapeamento do potencial
                </div>
                <div class="flowchart-note">
                    Ponta de prova percorre a cuba medindo potencial em v√°rios pontos
                </div>
                
                <div class="flowchart-arrow">‚Üì</div>
                
                <div class="flowchart-box output">
                    üìê LINHAS EQUIPOTENCIAIS<br>
                    Conex√£o de pontos
                </div>
                <div class="flowchart-note">
                    Pontos com mesmo potencial s√£o conectados formando linhas equipotenciais
                </div>
                
                <div class="flowchart-arrow">‚Üì</div>
                
                <div class="flowchart-box output">
                    üìä AN√ÅLISE<br>
                    Visualiza√ß√£o do campo
                </div>
                <div class="flowchart-note">
                    ‚Ä¢ Linhas pr√≥ximas = campo intenso<br>
                    ‚Ä¢ Linhas espa√ßadas = campo fraco<br>
                    ‚Ä¢ Perpendiculares √†s linhas de campo
                </div>
                
                <div class="flowchart-arrow">‚Üì</div>
                
                <div class="flowchart-box" style="background: linear-gradient(135deg, #ffa751 0%, #ffe259 100%);">
                    üéì CONCLUS√ÉO<br>
                    Comportamento eletrost√°tico
                </div>
                <div class="flowchart-note">
                    Demonstra como cargas criam campos el√©tricos no espa√ßo e como medi-los experimentalmente
                </div>
            </div>
        </div>
        
        <!-- CONTROLES ABAIXO (LARGURA TOTAL) -->
        <div class="controls-container">
            <div>
                <h2>‚öôÔ∏è Controles das Cargas</h2>
                <div id="chargeControls"></div>
                <div class="button-group">
                    <button class="btn-primary" onclick="addCharge()">‚ûï Adicionar Carga</button>
                    <button class="btn-secondary" onclick="resetSimulation()">üîÑ Reset</button>
                </div>
            </div>
            
            <div>
                <h2>üìä Legenda</h2>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff4444;"></div>
                        <span>Carga Positiva (+)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4444ff;"></div>
                        <span>Carga Negativa (‚àí)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00, #0000ff);"></div>
                        <span>Linhas Equipotenciais</span>
                    </div>
                </div>
            </div>
            
            <div>
                <h2>üìö Fundamentos F√≠sicos</h2>
                <div class="info-box">
                    <strong>Lei de Coulomb:</strong><br>
                    V = k¬∑Œ£(q/r)<br><br>
                    <strong>Linhas Equipotenciais:</strong><br>
                    ‚Ä¢ Conectam pontos de mesmo potencial<br>
                    ‚Ä¢ Perpendiculares ao campo el√©trico<br>
                    ‚Ä¢ Deformam-se com m√∫ltiplas cargas<br><br>
                    <strong>Intera√ß√£o:</strong><br>
                    Cargas opostas se atraem, modificando o campo el√©trico resultante.
                </div>
            </div>
        </div>
    </div>

    <script>
        /**
         * SIMULA√á√ÉO DE CUBA ELETROL√çTICA
         * 
         * Este c√≥digo simula o comportamento de cargas el√©tricas em uma cuba eletrol√≠tica,
         * calculando e visualizando as linhas equipotenciais resultantes.
         * 
         * ESTRUTURA DE DADOS:
         * - charges: array de objetos {x, y, q, dragging}
         *   x, y: posi√ß√£o da carga (pixels)
         *   q: magnitude da carga (coulombs, escalado)
         *   dragging: booleano indicando se est√° sendo arrastada
         */
        
        let charges = [];
        let selectedCharge = null;
        let canvasWidth = 700;
        let canvasHeight = 500;
        const K = 8.99e9; // Constante de Coulomb (simplificada para visualiza√ß√£o)
        
        /**
         * SETUP - Inicializa√ß√£o do p5.js
         * Configura o canvas e cria cargas iniciais
         */
        function setup() {
            let canvas = createCanvas(canvasWidth, canvasHeight);
            canvas.parent('canvasContainer');
            canvas.id('simulationCanvas');
            
            // Inicializa com duas cargas: uma positiva e uma negativa
            charges.push({
                x: 200,
                y: 250,
                q: 5, // Carga positiva
                dragging: false
            });
            
            charges.push({
                x: 500,
                y: 250,
                q: -5, // Carga negativa
                dragging: false
            });
            
            updateChargeControls();
        }
        
        /**
         * DRAW - Loop principal de renderiza√ß√£o
         * Executado 60 vezes por segundo
         */
        function draw() {
            // Fundo branco
            background(255);
            
            // 1¬∫ PASSO: Desenhar o mapa de potencial (cores de fundo)
            drawPotentialField();
            
            // 2¬∫ PASSO: Desenhar linhas equipotenciais
            drawEquipotentialLines();
            
            // 3¬∫ PASSO: Desenhar as cargas
            drawCharges();
            
            // 4¬∫ PASSO: Desenhar informa√ß√µes adicionais
            drawGrid();
        }
        
        /**
         * C√ÅLCULO DO POTENCIAL EL√âTRICO
         * 
         * F√≥rmula: V(r) = k * Œ£(qi/ri)
         * Onde:
         * - k √© a constante de Coulomb
         * - qi √© a carga i
         * - ri √© a dist√¢ncia do ponto √† carga i
         * 
         * @param {number} x - coordenada x do ponto
         * @param {number} y - coordenada y do ponto
         * @returns {number} - potencial el√©trico no ponto (x,y)
         */
        function calculatePotential(x, y) {
            let potential = 0;
            
            // Soma a contribui√ß√£o de cada carga
            for (let charge of charges) {
                // Calcula dist√¢ncia euclidiana
                let dx = x - charge.x;
                let dy = y - charge.y;
                let distance = Math.sqrt(dx * dx + dy * dy);
                
                // Evita divis√£o por zero (quando muito pr√≥ximo da carga)
                if (distance < 5) distance = 5;
                
                // V = k*q/r (simplificado, k=1 para visualiza√ß√£o)
                potential += charge.q / distance;
            }
            
            return potential;
        }
        
        /**
         * DESENHA CAMPO DE POTENCIAL
         * 
         * Cria um mapa de cores representando o potencial em cada ponto.
         * Vermelho = potencial alto (positivo)
         * Azul = potencial baixo (negativo)
         */
        function drawPotentialField() {
            let resolution = 10; // Pixels entre cada c√°lculo (performance)
            
            for (let x = 0; x < canvasWidth; x += resolution) {
                for (let y = 0; y < canvasHeight; y += resolution) {
                    let V = calculatePotential(x, y);
                    
                    // Mapeia potencial para cor
                    // Normaliza o valor para o intervalo [-1, 1]
                    let normalizedV = Math.tanh(V / 2);
                    
                    // Converte para RGB
                    let r, g, b;
                    if (normalizedV > 0) {
                        // Potencial positivo: branco -> vermelho
                        r = 255;
                        g = 255 * (1 - normalizedV * 0.5);
                        b = 255 * (1 - normalizedV * 0.5);
                    } else {
                        // Potencial negativo: branco -> azul
                        r = 255 * (1 + normalizedV * 0.5);
                        g = 255 * (1 + normalizedV * 0.5);
                        b = 255;
                    }
                    
                    noStroke();
                    fill(r, g, b, 100); // Alpha baixo para transpar√™ncia
                    rect(x, y, resolution, resolution);
                }
            }
        }
        
        /**
         * DESENHA LINHAS EQUIPOTENCIAIS
         * 
         * Linhas equipotenciais s√£o curvas que conectam pontos de mesmo potencial.
         * Usa algoritmo de contorno para tra√ßar as linhas.
         * As linhas se deformam de acordo com a presen√ßa de TODAS as cargas.
         */
        function drawEquipotentialLines() {
            // Define n√≠veis de potencial para desenhar - MUITO MAIS n√≠veis
            let levels = [];
            for (let i = -2.0; i <= 2.0; i += 0.05) {
                levels.push(i);
            }
            
            strokeWeight(2.5); // Linhas grossas
            
            // Para cada n√≠vel de potencial
            for (let level of levels) {
                // Cor baseada no n√≠vel com maior contraste
                let hue = map(level, -2.0, 2.0, 240, 0); // Azul para vermelho
                let sat = 180;
                let bright = 200;
                
                // Alpha varia para dar profundidade
                let alpha = map(Math.abs(level), 0, 2, 255, 100);
                
                colorMode(HSB);
                stroke(hue, sat, bright, alpha);
                colorMode(RGB);
                noFill();
                
                // Algoritmo de contorno - resolu√ß√£o ALTA para capturar deforma√ß√µes
                let resolution = 5; // Resolu√ß√£o muito fina!
                
                for (let x = 0; x < canvasWidth - resolution; x += resolution) {
                    for (let y = 0; y < canvasHeight - resolution; y += resolution) {
                        // Calcula potencial nos 4 cantos da c√©lula
                        let v1 = Math.tanh(calculatePotential(x, y) / 2);
                        let v2 = Math.tanh(calculatePotential(x + resolution, y) / 2);
                        let v3 = Math.tanh(calculatePotential(x + resolution, y + resolution) / 2);
                        let v4 = Math.tanh(calculatePotential(x, y + resolution) / 2);
                        
                        // Verifica se o n√≠vel cruza esta c√©lula
                        let min = Math.min(v1, v2, v3, v4);
                        let max = Math.max(v1, v2, v3, v4);
                        
                        if (level >= min && level <= max) {
                            // Desenha segmento de linha nesta c√©lula
                            drawContourSegment(x, y, resolution, level, v1, v2, v3, v4);
                        }
                    }
                }
            }
        }
        
        /**
         * DESENHA SEGMENTO DE CONTORNO
         * 
         * Usa interpola√ß√£o linear para encontrar pontos onde a linha equipotencial
         * cruza os lados da c√©lula.
         */
        function drawContourSegment(x, y, res, level, v1, v2, v3, v4) {
            let points = [];
            
            // Verifica cada lado da c√©lula
            // Lado superior
            if ((v1 - level) * (v2 - level) < 0) {
                let t = (level - v1) / (v2 - v1);
                points.push({x: x + t * res, y: y});
            }
            
            // Lado direito
            if ((v2 - level) * (v3 - level) < 0) {
                let t = (level - v2) / (v3 - v2);
                points.push({x: x + res, y: y + t * res});
            }
            
            // Lado inferior
            if ((v3 - level) * (v4 - level) < 0) {
                let t = (level - v4) / (v3 - v4);
                points.push({x: x + t * res, y: y + res});
            }
            
            // Lado esquerdo
            if ((v4 - level) * (v1 - level) < 0) {
                let t = (level - v1) / (v4 - v1);
                points.push({x: x, y: y + t * res});
            }
            
            // Conecta os pontos
            if (points.length === 2) {
                line(points[0].x, points[0].y, points[1].x, points[1].y);
            }
        }
        
        /**
         * DESENHA AS CARGAS EL√âTRICAS
         * 
         * Cargas positivas: c√≠rculos vermelhos com sinal +
         * Cargas negativas: c√≠rculos azuis com sinal -
         */
        function drawCharges() {
            for (let i = 0; i < charges.length; i++) {
                let charge = charges[i];
                
                // Tamanho proporcional √† magnitude da carga
                let size = map(Math.abs(charge.q), 0, 10, 20, 50);
                
                // Cor baseada no sinal
                if (charge.q > 0) {
                    fill(255, 50, 50); // Vermelho para positiva
                    stroke(200, 0, 0);
                } else {
                    fill(50, 50, 255); // Azul para negativa
                    stroke(0, 0, 200);
                }
                
                strokeWeight(3);
                
                // Destaque se estiver sendo arrastada
                if (charge.dragging) {
                    strokeWeight(5);
                    stroke(255, 200, 0);
                }
                
                // Desenha c√≠rculo
                ellipse(charge.x, charge.y, size, size);
                
                // Desenha sinal + ou -
                fill(255);
                noStroke();
                textAlign(CENTER, CENTER);
                textSize(size * 0.5);
                textStyle(BOLD);
                text(charge.q > 0 ? '+' : '‚àí', charge.x, charge.y);
                
                // Desenha valor da carga
                fill(0);
                textSize(12);
                text(charge.q.toFixed(1) + ' C', charge.x, charge.y + size/2 + 15);
            }
        }
        
        /**
         * DESENHA GRADE DE REFER√äNCIA
         */
        function drawGrid() {
            stroke(200, 200, 200, 100);
            strokeWeight(1);
            
            // Linhas verticais
            for (let x = 0; x < canvasWidth; x += 50) {
                line(x, 0, x, canvasHeight);
            }
            
            // Linhas horizontais
            for (let y = 0; y < canvasHeight; y += 50) {
                line(0, y, canvasWidth, y);
            }
        }
        
        /**
         * INTERA√á√ÉO COM MOUSE - Pressionar
         * 
         * Detecta se o usu√°rio clicou em uma carga para arrast√°-la
         */
        function mousePressed() {
            for (let charge of charges) {
                let d = dist(mouseX, mouseY, charge.x, charge.y);
                let size = map(Math.abs(charge.q), 0, 10, 20, 50);
                
                if (d < size / 2) {
                    charge.dragging = true;
                    selectedCharge = charge;
                    return;
                }
            }
        }
        
        /**
         * INTERA√á√ÉO COM MOUSE - Arrastar
         * 
         * Atualiza a posi√ß√£o da carga enquanto √© arrastada
         */
        function mouseDragged() {
            if (selectedCharge) {
                selectedCharge.x = constrain(mouseX, 0, canvasWidth);
                selectedCharge.y = constrain(mouseY, 0, canvasHeight);
            }
        }
        
        /**
         * INTERA√á√ÉO COM MOUSE - Soltar
         */
        function mouseReleased() {
            if (selectedCharge) {
                selectedCharge.dragging = false;
                selectedCharge = null;
            }
        }
        
        /**
         * ATUALIZA CONTROLES DA INTERFACE
         * 
         * Cria sliders para cada carga na interface
         */
        function updateChargeControls() {
            let container = document.getElementById('chargeControls');
            container.innerHTML = '';
            
            charges.forEach((charge, index) => {
                let controlDiv = document.createElement('div');
                controlDiv.className = 'charge-control';
                
                controlDiv.innerHTML = `
                    <div class="charge-header">
                        <span class="charge-label">Carga ${index + 1}</span>
                        <span class="charge-value" id="value-${index}">${charge.q.toFixed(1)} C</span>
                    </div>
                    <input 
                        type="range" 
                        min="-10" 
                        max="10" 
                        step="0.5" 
                        value="${charge.q}"
                        oninput="updateCharge(${index}, this.value)"
                    >
                    <button 
                        class="btn-secondary" 
                        style="margin-top: 8px; width: 100%;"
                        onclick="removeCharge(${index})"
                    >
                        üóëÔ∏è Remover
                    </button>
                `;
                
                container.appendChild(controlDiv);
            });
        }
        
        /**
         * ATUALIZA VALOR DE UMA CARGA
         */
        function updateCharge(index, value) {
            charges[index].q = parseFloat(value);
            document.getElementById(`value-${index}`).textContent = parseFloat(value).toFixed(1) + ' C';
        }
        
        /**
         * ADICIONA NOVA CARGA
         */
        function addCharge() {
            if (charges.length < 6) {
                charges.push({
                    x: Math.random() * canvasWidth,
                    y: Math.random() * canvasHeight,
                    q: Math.random() * 10 - 5,
                    dragging: false
                });
                updateChargeControls();
            } else {
                alert('M√°ximo de 6 cargas permitido para manter a performance!');
            }
        }
        
        /**
         * REMOVE UMA CARGA
         */
        function removeCharge(index) {
            if (charges.length > 1) {
                charges.splice(index, 1);
                updateChargeControls();
            } else {
                alert('Precisa haver pelo menos uma carga!');
            }
        }
        
        /**
         * RESETA A SIMULA√á√ÉO
         */
        function resetSimulation() {
            charges = [
                {x: 200, y: 250, q: 5, dragging: false},
                {x: 500, y: 250, q: -5, dragging: false}
            ];
            updateChargeControls();
        }
    </script>
</body>
</html>